<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title> · 三人五子棋 · </title>
    <link rel="icon" href="images/black-cat.png">
    <style>
        @font-face {
            font-family: 'ZZTY';
            src: url('ttf/ZiZongYiTiv1.002-2.ttf');
        }
        @font-face {
            font-family: 'XHNZ';
            src: url('ttf/XiangHeNiZhuangGeManHuai-2.ttf');
        }
        @font-face {
            font-family: 'XXRT';
            src: url('ttf/XiaoXiongRuanTangWeiWeiTian-2.ttf');
        }
        .gobang {
            width: 640px;
            margin: 0 auto;
        }
        .header {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }
        .header .btns button {
            margin-left: 5px;
            padding: 0 5px;
        }
        #my-canvas {
            background-color: #323232;
            border-radius: 4px;
        }
        .tips {
            font-family: 'XHNZ';
            font-size: 1.5em;
        }
        .btnr1, .btnp1 {
            border: none;
            height: 1.5em;
            background-color: #323232;
            color: #ffffff;
            border-radius: 0.5em;
            font-family: 'XHNZ';
            font-size: 1.25em;
        }
        .btnr1:hover, .btnp1:hover {
            border: none;
            height: 1.5em;
            background-color: #1f1f1f;
            color: #ffffff;
            border-radius: 0.5em;
            font-family: 'XHNZ';
            font-size: 1.25em;
        }
    </style>
  </head>
  <body>
    <div class="gobang">
        <div class="header">
            <span class="tips">当前：红子</span>
            <div class="btns">
                <button class="btnr1" onclick="restart()">重新开始</button>
                <button class="btnp1" :disabled="!cacheIndex || gameOver" onclick="popStack()">悔棋</button>
            </div>
        </div>
        <canvas id="my-canvas" width="640" height="640" onclick="canvasClick(event)"></canvas>
    </div>

    <script>
        const canvasRef = document.querySelector('#my-canvas')
        const ctx = canvasRef.getContext('2d')
        
        const tipsRef = document.querySelector('.tips')
        const rcs = 14 //格子数
        const gap = 42 //格子大小
        const radius = 20 //棋子大小
        const padding = 25 //棋盘边距
        let gameOver = false //游戏结束
        let current = 3 //？？？

        let data = new Array(rcs + 1).fill(0).map(() => new Array(rcs + 1))
        const restart = () => {
            data = new Array(rcs + 1).fill(0).map(() => new Array(rcs + 1))
            cacheIndex = 0
            cacheData.length = 1
            current = 3
            gameOver = false
            init ()
        }

        const canvasClick = (e) => {
            if (gameOver) {
                return
            }
            playAudio()
            const { offsetX, offsetY } = e
            const posi = getPostions(offsetX, offsetY, gap, padding, radius)
            if (posi && !data[posi[0]][posi[1]]) {
                data[posi[0]][posi[1]] = current
                init ()
                pushStack(data)
                const res = isOver(data, posi)
                if (res) {
                    gameOver = true
                    setTimeout(() => {
                        if (current == 1) {
                            const msg = res ? "黄棋胜利！" : "平局！";
                            alert('游戏结束：' + msg)
                        } else if (current == 2) {
                            const msg = res ? "红棋胜利！" : "平局！";
                            alert('游戏结束：' + msg)
                        } else {
                            const msg = res ? "蓝棋胜利！" : "平局！";
                            alert('游戏结束：' + msg)
                        }
                    }, 50)
                }console.log(res);
            }
        }

        const ds = [
            [
                [-1, 1], [1, -1]
            ], [
                [0, 1], [0, -1]
            ], [
                [1, 1], [-1, -1]
            ], [
                [1, 0], [-1, 0]
            ]
        ]

        function getPostionResult(data, x, y, m, n) {
            const val = data[x][y]

            for (let i = 0; i < ds.length; i++) {
                const [[lx, ly], [rx, ry]] = ds[i]
                let nx = x, ny = y, cnt = 1
                for (let j = 0; j < 4; j++) {
                    nx += lx
                    ny += ly
                    if (!(nx >= 0 && nx < m && ny >= 0 && ny < n) || data[nx][ny] !==val) {
                        break
                    }
                    cnt++
                }

                nx = x
                ny = y
                for (let j = 0; j < 4; j++) {
                    nx += rx
                    ny += ry
                    if (!(nx >= 0 && nx < m && ny < n) || data[nx][ny] !==val) {
                        break
                    }
                    cnt++
                }
                if (cnt >= 5) {
                    return true
                }
            }
            return false
        }

        const isOver = (data, posi) => {
            const m = data.length, n = data[0].length
            let nullCnt = m * n

            if (getPostionResult(data, posi[0], posi[1], m, n)) {
                return posi
            }

            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (data[i][j] !== undefined) {
                        nullCnt--
                    }
                }
            }

            return !nullCnt
        }

        const drawChessboard = (ctx, rcs, gap, padding) => {
            ctx.beginPath()
            ctx.lineWidth = 1
            // 竖排线条 从上到下
            for (let i = 0; i <= rcs; i++) {
                ctx.moveTo(padding + gap * i, padding)
                ctx.lineTo(padding + gap * i, padding + gap * rcs)
            }
            // 横排线条 从左到右
            for (let i = 0; i <= rcs; i++) {
                ctx.moveTo(padding, padding + gap * i)
                ctx.lineTo(padding + gap * rcs, padding + gap * i)
            }
            ctx.strokeStyle = "#fff" //线条颜色
            ctx.stroke()
            ctx.closePath()

            const pgra = padding + gap * rcs / 2 //通过边距+格子数*格子大小/2 获取中心点
            const gap4 = gap * 4 //乘几就几格

            //中心点
            ctx.beginPath()
            ctx.arc(pgra, pgra, 5, 0, 2 * Math.PI)
            ctx.fillStyle = '#fff'
            ctx.fill()
            //左上角
            ctx.beginPath()
            ctx.arc(pgra - gap4, pgra - gap4, 5, 0, 2 * Math.PI)
            ctx.fill()
            //左下角
            ctx.beginPath()
            ctx.arc(pgra - gap4, pgra + gap4, 5, 0, 2 * Math.PI)
            ctx.fill()
            //右上角
            ctx.beginPath()
            ctx.arc(pgra + gap4, pgra - gap4, 5, 0, 2 * Math.PI)
            ctx.fill()
            //右下角
            ctx.beginPath()
            ctx.arc(pgra + gap4, pgra + gap4, 5, 0, 2 * Math.PI)
            ctx.fill()
            ctx.closePath()
        }

        function drawBluePieces(ctx, ci, cj, si, sj, radius = 20) {
            ctx.beginPath()
            const lg2 = ctx.createRadialGradient(ci, cj, 5, ci, cj, 20)
            lg2.addColorStop(0.1, '#FFFFFF')
            lg2.addColorStop(0.9, '#99FFFF')
            ctx.fillStyle = lg2
            ctx.arc(si, sj, radius, 0, 2 * Math.PI)
            ctx.fill()
        }

        function drawRedPieces(ctx, ci, cj, si, sj, radius = 20) {
            ctx.beginPath()
            const lg2 = ctx.createRadialGradient(ci, cj, 5, ci, cj, 20)
            lg2.addColorStop(0.1, '#FF6633')
            lg2.addColorStop(0.9, '#ff3333')
            ctx.fillStyle = lg2
            ctx.arc(si, sj, radius, 0, 2 * Math.PI)
            ctx.fill()
            ctx.closePath()
        }

        function drawYellowPieces(ctx, ci, cj, si, sj, radius = 20) {
            ctx.beginPath()
            const lg2 = ctx.createRadialGradient(ci, cj, 5, ci, cj, 20)
            lg2.addColorStop(0.1, '#ffff66')
            lg2.addColorStop(0.9, '#ffff33')
            ctx.fillStyle = lg2
            ctx.arc(si, sj, radius, 0, 2 * Math.PI)
            ctx.fill()
            ctx.closePath()
        }

        const drawPieces = (ctx, data, gap, padding, radius = 20) => {
            const m = data.length, n = data[0].length
            for (let i = 0; i < m; i++) {
                const cj = i * gap + padding + 6 - padding
                const sj = padding + i * gap
                for (let j = 0; j < n; j++) {
                    if (data[i][j] === undefined) {
                        continue
                    }
                    const ci = j * gap + padding + 6 - padding
                    const si = padding + j * gap
                    if (data[i][j] == 1) {
                        drawRedPieces(ctx, ci, cj, si, sj, radius)
                    } else if (data[i][j] == 2){
                        drawBluePieces(ctx, ci, cj, si, sj, radius)
                    } else {
                        drawYellowPieces(ctx, ci, cj, si, sj, radius)
                    }
                    console.log(current);
                }
            }
        }

        const getPostions = (offsetX, offsetY, gap, padding, r = 20) => {
            const x = Math.round((offsetY - padding) / gap)
            const y = Math.round((offsetX - padding) / gap)
            const x1 = x * gap + padding, y1 = y * gap + padding
            const nr = Math.pow(Math.pow(x1 - offsetY, 2) + Math.pow(y1 - offsetX, 2), 0.5)
            if (nr <= r) {
                return [x, y]
            }
            return false
        }

        const cloneDeep = (data) => {
            const m = data.length, n = data[0].length
            const res = new Array(m).fill(0).map(() => new Array(n))

            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (data[i][j] !== undefined) {
                        res[i][j] = data[i][j]
                    }
                }
            }
            return res
        }

        const cacheData = [cloneDeep(data)]
        let cacheIndex = 0

        const pushStack = (data) => {
            cacheData.push(cloneDeep(data))
            cacheIndex++
        }
        const popStack = () => {
            if (cacheIndex && !gameOver) {
                data = cloneDeep(cacheData[--cacheIndex])
                cacheData.length = cacheIndex + 1
                if(current == 1) current = 2
                else current -= 2
                init()
            }
        }

        function playAudio() {
            const audio = document.createElement('audio')
            audio.src = 'wav/marking.wav'
            audio.play()
        }


        function init() {
            canvasRef.width = 640
            drawChessboard(ctx, rcs, gap, padding)
            drawPieces(ctx, data, gap, padding, radius)
            if(current <= 2) current += 1
            else if(current >= 3) current = 1

            setTimeout (() => {
                if (current == 1) tipsRef.innerHTML = '当前：红子'
                if (current == 2) tipsRef.innerHTML = '当前：蓝子'
                if (current == 3) tipsRef.innerHTML = '当前：黄子'
            }, 100)
        }
        init()
    </script>
  </body>
</html>
